# 09 메모리 모델과 이름공간
---
### 09.1 분할 컴파일

컴파일 시에는 여러가지 파일을 따로 처리하는 경우가 있다. 하지만 구조체등  선언을 동일하게 사용한다면.
양쪽 파일 모두에 넣어야 한다.
 수정해야 하는 경우 모든 파일을 수정해야 한다.

다음 경우 헤더파일에 넣어서 사용하면 추후 수정시 헤더파일만 수정하고 컴파일 하면 수정된다.
- 함수 원형
- #difine, const를 사용하여 정의하는 기호상수
- 구조체 선언
- 클래스 선언
 - 템플릿 선언
- 인라인 함수

헤더파일에 함수 정의, 변수선언이 있고, 헤더파일이 포함된 파일이 가지고 있다면 중복선언으로 인한 오류가 발생하기 때문에 사용하지 않는다.

또한 해당 헤더파일에 존재하는 것들에 대한 함수들을 각각의 파일을 만들어 위치 시키면 좀 더 간편하게 사용 가능하다.

#ifndef는 해당 헤더파일이 존재하지 않으면, #endif 사이의 구문을 처리한다.

```cpp
// coordin.h -- 구조체 템플릿과 함수 원형
// 구조체 템플릿
#ifndef COORDIN_H_  //COORDIN_H_가 존재하지 않으면 다음 구문을 실행한다.
#define COORDIN_H_

struct polar
{
	double distance;	// 원점으로부터의 거리
	double angle;		// 수평축으로부터의 각도
};
struct rect
{
	double x;		// 원점으로부터의 수평 거리
	double y;		// 원점으로부터의 수직 거리
};

// 원형
polar rect_to_polar(rect xypos);
void show_polar(polar dapos);

#endif

```

```cpp
// file1.cpp -- 세 개의 파일로 구성된 프로그램의 예
#include <iostream>
#include "coordin.h"				// 구조체 템플릿, 함수 원형
using namespace std;
int main()
{
	rect rplace;
	polar pplace;

	cout << "x값과 y값을 입력하십시오: ";
	while (cin >> rplace.x >> rplace.y)	// 재치 있는 cin 사용
	{
		pplace = rect_to_polar(rplace);
		show_polar(pplace);
		cout << "x값과 y값을 입력하십시오(끝내려면 q를 입력): ";
	}
	cout << "프로그램을 종료합니다.\n";
	return 0;
}
```

```cpp
// file2.cpp -- file1.cpp에서 호출되는 함수가 들어 있다
#include <iostream>
#include <cmath>
#include "coordin.h"	// 구조체 템플릿, 함수 원형

// 직각 좌표를 극 좌표로 변환한다
polar rect_to_polar(rect xypos)
{
	using namespace std;
	polar answer;

	answer.distance =
		sqrt(xypos.x * xypos.x + xypos.y * xypos.y);
	answer.angle = std::atan2(xypos.y, xypos.x);
	return answer;		// polar형 구조체를 리턴한다
}

// 라디안 단위를 도 단위로 변환하여 극 좌표를 출력한다
void show_polar(polar dapos)
{
	using namespace std;
	const double Rad_to_deg = 57.29577951;

	cout << "거리 = " << dapos.distance;
	cout << ", 각도 = " << dapos.angle * Rad_to_deg;
	cout << "도\n";
}

```

---
### 09.2 기억 존속 시간, 사용 범위, 링크

기억 존속시간
- 자동 기억 존속 시간 -함수 또는 블록을 들어갈 때 생성하고 해제되는 메모리
- 정적 기억 존속 시간 -함수 바깥에서 정의된 변수 또는 static을 사용해 정의된 변수, 프로그램 전체에서 존재하는 메모리
- 쓰레드 존속 시간 -멀티 쓰레드를 통해 병렬 작업을 처리하는 동안 존재하는 메모리
- 동적 기억 존속 시간 -new 부터 delete 또는 프로그램 종료 중 먼저 일어날 때 까지 존재하는 메모리

**자동변수**
자동 기억 존속 시간울 가지는 변수

```cpp
#include <iostream>
using namespace std;

int main()
{
    bool a = 1;
    cout << a << endl;
    {
        cout << a << endl;
        bool a = 0;
        cout << a << endl;
    }
    cout << a << endl;
}
//출력값
//1
//1
//0
//1
```

자동변수와 스택
스택 구조로 사용한다

레지스터 변수
register라는 키워드를 사용하는 변수는 C++에서는 자주 사용되는 변수라는 의미로 컴파일러가 특별조치를 한다는 의미를 가진다
C++ 11에서는 자동변수임을 명시한다.

**정적 변수**
정적 기억 존속 시간을 가지는 변수이다.
명시적으로 초기화 하지 않으면 0으로 초기화 된다.
```cpp
#include <iostream>
using namespace std;

bool a;             //외부링크
static bool b;      //내부링크
int main()
{
    static bool c;  //링크없음
    cout << a << endl << b << endl << c;
}
//출력값
//0
//0
//0
```

기억공간 | 기억 존속 시간 | 사용 범위 | 링크 | 선언방법
---|---|---|---|---
자동|자동|블록|없음|블록안
레지스터|자동|블록|없음|블록안(register사용)
링크 없는 정적|정적|블록|없음|블록안에(static사용)
외부 링크 정적|정적|파일|외부|함수의 바깥
링크 없는 정적|정적|파일|내부|함수의 바깥에(static사용)


외부 링크, 정적 존속 시간
2가지 종류의 변수선언이 존재
- 선언을 정의하고 대입하는 것
- 참조 선언 또는 단순히 선언(기존의 변수를 의미)
참조 선언은 extern 키워드를 사용한다.
다중 파일 프로그램에서도 하나의 이름으로 하나의 파일에서만 선언해야한다.
다른 파일에서 사용하려면 참조 선언이 필요하다.

내부 링크, 정적 존속 시간
파일에 해당하는 동안만 변수가 사용된다.

링크 없음, 정적 기억 존속 시간
```cpp
#include <iostream>
using namespace std;
void print();
void count();
bool a;             //외부링크
static bool b;      //내부링크
int main()
{
    static bool c;  //링크없음
    cout << "외부링크a : " << a << endl
         << "내부링크b : " << b << endl
         << "링크없음c : " << c << endl;
    
    print();
    for(int i=0;i<3;i++)
    {
        count();
    }
}
//출력값
//외부링크a : 0
//내부링크b : 0
//링크없음c : 0
//외부 변수를 참조a : 0
//file1의 내부변수b : 1
//123
```
```cpp
#include <iostream>
using namespace std;

extern bool a; //외부변수 참조선언
static bool b = 1; //내부변수로 b를 선언

void print()
{
    cout << "외부 변수를 참조a : " << a << endl
         << "file1의 내부변수b : " << b << endl;
    return;
}

void count()
{
    static int d; //링크없는 정적 변수
    cout << ++d; //정적변수가 아니라면 항상 0만 출력해야함
}
```

제한자
키워드를 통해 기억공간에 대한 제한
- auto(C++11에서 제외)
- register
- static
- extern
- thread_local(C++11에서 추가)
- mutable

cv-제한자
- const
- volatile

